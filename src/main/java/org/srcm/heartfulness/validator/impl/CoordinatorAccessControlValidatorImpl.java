package org.srcm.heartfulness.validator.impl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.srcm.heartfulness.constants.CoordinatorAccessControlConstants;
import org.srcm.heartfulness.constants.ErrorConstants;
import org.srcm.heartfulness.model.Program;
import org.srcm.heartfulness.model.ProgramCoordinators;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlErrorResponse;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlResponse;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlSuccessResponse;
import org.srcm.heartfulness.repository.CoordinatorAccessControlRepository;
import org.srcm.heartfulness.validator.CoordinatorAccessControlValidator;

@Component
public class CoordinatorAccessControlValidatorImpl implements CoordinatorAccessControlValidator {

	private static final Logger LOGGER = LoggerFactory.getLogger(CoordinatorAccessControlValidatorImpl.class);

	@Autowired
	CoordinatorAccessControlRepository coordntrAccssCntrlRepo;

	/**
	 * This method is used to validate the mandatory event params.
	 * @param autoGeneratedEventId user should not pass this value null
	 * or empty
	 * @return CoordinatorAccessControlErrorResponse is the validation 
	 * fails else null is returned.
	 */
	@Override
	public CoordinatorAccessControlErrorResponse checkMandatoryFields(String autoGeneratedEventId) {

		if (null == autoGeneratedEventId || autoGeneratedEventId.isEmpty()) {
			CoordinatorAccessControlErrorResponse eResponse = new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.EMPTY_EVENT_ID);
			return eResponse;
		}
		return null;
	}


	/**
	 * This method is used to validate the mandatory params 
	 * before approving request for a secondary coordinator.
	 * @param approvedBy email of the primary coordinator
	 * or the preceptor for that event.
	 * @param pgrmCoordinators to get the email of the secondary coordinator 
	 * and the eventId for which secondary coordinator has requested for access.
	 * @return CoordinatorAccessControlResponse depending on the response is 
	 * success or failure.
	 */
	@Override
	public CoordinatorAccessControlResponse validateCoordinatorRequest(String approvedBy,ProgramCoordinators pgrmCoordinators) {

		if(null == pgrmCoordinators.getEmail() || pgrmCoordinators.getEmail().isEmpty()){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.REQUESTER_EMAIL_INVALID);
		}

		if(approvedBy.equalsIgnoreCase(pgrmCoordinators.getEmail())){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_SAME_APPROVER_REQUESTER);
		}

		if (null == pgrmCoordinators.getEventId() || pgrmCoordinators.getEventId().isEmpty()) {
			CoordinatorAccessControlErrorResponse eResponse = new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.EMPTY_EVENT_ID);
			return eResponse;
		}
		
		Program program = null; //= new Program();
		try{
			program = coordntrAccssCntrlRepo.getProgramIdByEventId(pgrmCoordinators.getEventId());
			pgrmCoordinators.setProgramId(program.getProgramId());
		}catch(Exception ex){
			LOGGER.error("Event not available for event id " +pgrmCoordinators.getEventId());
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_EVENT_ID);
		}
		
		//Validate whether person is authorized to approve request
		ProgramCoordinators preceptorDetails = null; // = new ProgramCoordinators();
		try{
			preceptorDetails = coordntrAccssCntrlRepo.getProgramCoordinatorByProgramId(program.getProgramId());
		}catch(Exception ex){
			LOGGER.error("Preceptor not available for event "+pgrmCoordinators.getEventId());
		}
		
		if(!approvedBy.equalsIgnoreCase(program.getCoordinatorEmail()) && (null != preceptorDetails && !approvedBy.equalsIgnoreCase(preceptorDetails.getEmail()))){
			
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_NO_AUTHORITY);
		}
		
		int alreadyApproved = -1;
		try{
			alreadyApproved = coordntrAccssCntrlRepo.checkRequestAlreadyApproved(program.getProgramId(), pgrmCoordinators.getEmail());
		}catch(Exception ex){
			LOGGER.error("Request is not approved for event Id " +pgrmCoordinators.getEventId());
		}
		if(alreadyApproved > 0){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_REQUEST_ALREADY_APPROVED);
		}else if(alreadyApproved == -1){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_REQUEST);
		}
		
		int requestCount = -1;
		try{
			requestCount = coordntrAccssCntrlRepo.checkRequestAlreadyRaised(program.getProgramId(), pgrmCoordinators.getEmail());
		}catch(Exception ex){
			LOGGER.error("Request not raised for the event Id " +pgrmCoordinators.getEventId() +" by "+pgrmCoordinators.getEmail());
		}
		if(requestCount == 1){
			return new CoordinatorAccessControlSuccessResponse(ErrorConstants.STATUS_SUCCESS,CoordinatorAccessControlConstants.APPROVER_VALIDATION_SUCCESSFULL);
		}else if(requestCount != 1){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_REQUEST_DOESNOT_EXIST);
		}else{
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_REQUEST);
		}

	}

	
	/**
	 * This method is used to validate the mandatory params required
	 * inorder to fetch the list of secondary coordinator requests.
	 * @param loggedInUserEmail email of the primary coordinator or preceptor.
	 * @param autoGeneratedEventId to get the programId of an event.
	 * @return CoordinatorAccessControlResponse depending on the response is 
	 * success or failure.
	 */
	@Override
	public CoordinatorAccessControlResponse validateRequesterDetails(String loggedInUserEmail, String autoGeneratedEventId) {
		
		
		if (null == autoGeneratedEventId || autoGeneratedEventId.isEmpty()) {
			CoordinatorAccessControlErrorResponse eResponse = new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.EMPTY_EVENT_ID);
			return eResponse;
		}
		
		Program program = null;
		try{
			program = coordntrAccssCntrlRepo.getProgramIdByEventId(autoGeneratedEventId);
		}catch(Exception ex){
			LOGGER.error("Event not available for event id " +autoGeneratedEventId);
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_EVENT_ID);
		}
		
		ProgramCoordinators preceptorDetails = null; 
		try{
			preceptorDetails = coordntrAccssCntrlRepo.getProgramCoordinatorByProgramId(program.getProgramId());
		}catch(Exception ex){
			LOGGER.error("Preceptor not available for event "+autoGeneratedEventId);
		}
		
		if(!loggedInUserEmail.equalsIgnoreCase(program.getCoordinatorEmail()) && (null != preceptorDetails && !loggedInUserEmail.equalsIgnoreCase(preceptorDetails.getEmail()))){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.REQUESTERLIST_NO_AUTHORITY);
		}
		
		return new CoordinatorAccessControlSuccessResponse(ErrorConstants.STATUS_SUCCESS,CoordinatorAccessControlConstants.REQUESTERLIST_VALIDATION_SUCCESSFULL);
	}

}
