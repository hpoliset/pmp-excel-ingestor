package org.srcm.heartfulness.validator.impl;

import java.util.LinkedHashMap;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.srcm.heartfulness.constants.CoordinatorAccessControlConstants;
import org.srcm.heartfulness.constants.ErrorConstants;
import org.srcm.heartfulness.constants.PMPConstants;
import org.srcm.heartfulness.model.Program;
import org.srcm.heartfulness.model.ProgramCoordinators;
import org.srcm.heartfulness.model.User;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlErrorResponse;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlResponse;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlSuccessResponse;
import org.srcm.heartfulness.repository.CoordinatorAccessControlRepository;
import org.srcm.heartfulness.repository.ProgramRepository;
import org.srcm.heartfulness.validator.CoordinatorAccessControlValidator;

@Component
public class CoordinatorAccessControlValidatorImpl implements CoordinatorAccessControlValidator {

	private static final Logger LOGGER = LoggerFactory.getLogger(CoordinatorAccessControlValidatorImpl.class);

	@Autowired
	CoordinatorAccessControlRepository coordntrAccssCntrlRepo;


	@Autowired
	ProgramRepository pgrmRepository;

	/**
	 * This method is used to validate the mandatory event params.
	 * @param autoGeneratedEventId user should not pass this value null
	 * or empty
	 * @return CoordinatorAccessControlErrorResponse is the validation 
	 * fails else null is returned.
	 */
	@Override
	public CoordinatorAccessControlErrorResponse checkMandatoryFields(String autoGeneratedEventId) {

		if (null == autoGeneratedEventId || autoGeneratedEventId.isEmpty()) {
			CoordinatorAccessControlErrorResponse eResponse = new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.EMPTY_EVENT_ID);
			return eResponse;
		}
		return null;
	}


	/**
	 * This method is used to validate the mandatory params 
	 * before approving request for a secondary coordinator.
	 * @param approvedBy email of the primary coordinator
	 * or the preceptor for that event.
	 * @param pgrmCoordinators to get the email of the secondary coordinator 
	 * and the eventId for which secondary coordinator has requested for access.
	 * @return CoordinatorAccessControlResponse depending on the response is 
	 * success or failure.
	 */
	@Override
	public CoordinatorAccessControlResponse validateCoordinatorRequest(String approvedBy,ProgramCoordinators pgrmCoordinators) {

		if(null == pgrmCoordinators.getEmail() || pgrmCoordinators.getEmail().isEmpty()){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.REQUESTER_EMAIL_INVALID);
		}

		if(approvedBy.equalsIgnoreCase(pgrmCoordinators.getEmail())){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_SAME_APPROVER_REQUESTER);
		}

		if (null == pgrmCoordinators.getEventId() || pgrmCoordinators.getEventId().isEmpty()) {
			CoordinatorAccessControlErrorResponse eResponse = new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.EMPTY_EVENT_ID);
			return eResponse;
		}

		Program program = null; //= new Program();
		try{
			program = coordntrAccssCntrlRepo.getProgramIdByEventId(pgrmCoordinators.getEventId());
			pgrmCoordinators.setProgramId(program.getProgramId());
		}catch(Exception ex){
			LOGGER.error("Event not available for event id " +pgrmCoordinators.getEventId());
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_EVENT_ID);
		}


		//Validate whether person is authorized to approve request
		ProgramCoordinators preceptorDetails = new ProgramCoordinators();
		try{
			preceptorDetails = coordntrAccssCntrlRepo.getProgramCoordinatorByProgramId(program.getProgramId());
		}catch(Exception ex){
			LOGGER.error("Preceptor not available for event "+pgrmCoordinators.getEventId());
		}

		if(!approvedBy.equalsIgnoreCase(program.getCoordinatorEmail()) && !approvedBy.equalsIgnoreCase(preceptorDetails.getEmail())){

			User user = null;
			try {
				user = coordntrAccssCntrlRepo.getUserbyUserEmail(approvedBy);
			} catch (Exception ex) {
				LOGGER.error("Unable to fetch profile using mail {}",approvedBy );
			}

			if(null != user ? !user.getRole().equals(PMPConstants.LOGIN_ROLE_ADMIN) ? !user.getRole().equals(PMPConstants.LOGIN_GCONNECT_ADMIN) : false : true ){
				return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_NO_AUTHORITY);
			}
		}

		int alreadyApproved = -1;
		try{
			alreadyApproved = coordntrAccssCntrlRepo.checkRequestAlreadyApproved(program.getProgramId(), pgrmCoordinators.getEmail());
		}catch(Exception ex){
			LOGGER.error("Request is not approved for event Id " +pgrmCoordinators.getEventId());
		}
		if(alreadyApproved > 0){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_REQUEST_ALREADY_APPROVED);
		}else if(alreadyApproved == -1){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_REQUEST);
		}

		int requestCount = -1;
		try{
			requestCount = coordntrAccssCntrlRepo.checkRequestAlreadyRaised(program.getProgramId(), pgrmCoordinators.getEmail());
		}catch(Exception ex){
			LOGGER.error("Request not raised for the event Id " +pgrmCoordinators.getEventId() +" by "+pgrmCoordinators.getEmail());
		}
		if(requestCount == 1){
			return new CoordinatorAccessControlSuccessResponse(ErrorConstants.STATUS_SUCCESS,CoordinatorAccessControlConstants.APPROVER_VALIDATION_SUCCESSFULL);
		}else if(requestCount != 1){
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.APPROVER_REQUEST_DOESNOT_EXIST);
		}else{
			return new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.INVALID_REQUEST);
		}

	}

	/**
	 * This method is used to get all the program Id and auto generated
	 * event Id's for the logged in user have conducted.
	 * @param emailList List of emails associated witha abhyasi id for the 
	 * logged in user.
	 * @param userRole, role of the logged in user.
	 * @return LinkedHashMap<Integer,String> containing program Id and auto generated
	 * event Id's for the logged in user have conducted.
	 */
	@Override
	public LinkedHashMap<Integer,String> getProgramAndagEventIds(List<String> emailList,String userRole) {

		return pgrmRepository.getListOfProgramIdsByEmail(emailList,userRole);
	}

}
