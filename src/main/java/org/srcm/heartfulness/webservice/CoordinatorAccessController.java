package org.srcm.heartfulness.webservice;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.Context;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.HttpClientErrorException;
import org.srcm.heartfulness.constants.CoordinatorAccessControlConstants;
import org.srcm.heartfulness.constants.DashboardConstants;
import org.srcm.heartfulness.constants.ErrorConstants;
import org.srcm.heartfulness.model.PMPAPIAccessLog;
import org.srcm.heartfulness.model.ProgramCoordinators;
import org.srcm.heartfulness.model.User;
import org.srcm.heartfulness.model.json.request.Event;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlErrorResponse;
import org.srcm.heartfulness.model.json.response.CoordinatorAccessControlResponse;
import org.srcm.heartfulness.model.json.response.ErrorResponse;
import org.srcm.heartfulness.model.json.response.PMPResponse;
import org.srcm.heartfulness.model.json.response.UserProfile;
import org.srcm.heartfulness.service.APIAccessLogService;
import org.srcm.heartfulness.service.CoordinatorAccessControlService;
import org.srcm.heartfulness.service.UserProfileService;
import org.srcm.heartfulness.util.DateUtils;
import org.srcm.heartfulness.util.StackTraceUtils;
import org.srcm.heartfulness.validator.CoordinatorAccessControlValidator;
import org.srcm.heartfulness.validator.EventDashboardValidator;
import org.srcm.heartfulness.validator.impl.PMPAuthTokenValidatorImpl;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;

/**
 * 
 * @author Koustav Dutta
 *
 */

@RestController
@RequestMapping("/api/coordinatoraccess")
public class CoordinatorAccessController {

	private static final Logger LOGGER = LoggerFactory.getLogger(CoordinatorAccessController.class);

	@Autowired
	CoordinatorAccessControlValidator coordntrAccssCntrlValidator ;

	@Autowired
	APIAccessLogService apiAccessLogService;

	@Autowired
	EventDashboardValidator eventDashboardValidator;

	@Autowired
	CoordinatorAccessControlService coordntrAccssCntrlSrcv;

	@Autowired
	private UserProfileService userProfileService;

	@Autowired
	PMPAuthTokenValidatorImpl authTokenVldtr;


	/**
	 * This method is used to raise a request by the coordinators
	 * to access other events for which they don't have access.
	 * 
	 * @param token to be validated against MySRCM endpoint.
	 * @param event to get the auto generated event id of an event 
	 * for which the coordinator is requesting to get access.
	 * @param httpRequest to get the requested url details.
	 * @return CoordinatorAccessControlResponse 
	 * 
	 */
	@RequestMapping(value = "/addsecondarycoordinator", 
			method = RequestMethod.POST,
			consumes = MediaType.APPLICATION_JSON_VALUE,
			produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity<?> addSecondaryCoordinatorRequest(@RequestHeader(value = "Authorization") String authToken,
			@RequestBody Event event,@Context HttpServletRequest httpRequest) {


		//save request details in PMP
		PMPAPIAccessLog accessLog = createPMPAPIAccessLog(null,httpRequest,StackTraceUtils.convertPojoToJson(event));

		//validate token details
		PMPResponse pmpResponse = authTokenVldtr.validateAuthToken(authToken, accessLog);
		if(pmpResponse instanceof ErrorResponse){
			return new ResponseEntity<PMPResponse>(pmpResponse, HttpStatus.OK);
		}

		User user = userProfileService.loadUserByEmail(accessLog.getUsername());

		if (null == user) {

			LOGGER.info(DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			ErrorResponse eResponse = new ErrorResponse(ErrorConstants.STATUS_FAILED,DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			accessLog.setErrorMessage(DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			updatePMPAPIAccessLog(accessLog,ErrorConstants.STATUS_FAILED,DashboardConstants.USER_UNAVAILABLE_IN_PMP, StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<ErrorResponse>(eResponse, HttpStatus.BAD_REQUEST);
		}

		CoordinatorAccessControlErrorResponse eResponse = coordntrAccssCntrlValidator.checkMandatoryFields(event.getAutoGeneratedEventId());
		if(null != eResponse){
			updatePMPAPIAccessLog(accessLog, accessLog.getStatus(), eResponse.getError_description(), StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<CoordinatorAccessControlErrorResponse>(eResponse, HttpStatus.PRECONDITION_REQUIRED);	
		}

		try{

			CoordinatorAccessControlResponse response = coordntrAccssCntrlSrcv.addSecondaryCoordinatorRequest(event.getAutoGeneratedEventId(),accessLog.getUsername()
					,event.getSecondaryCoordinatorNotes(),accessLog);
			return new ResponseEntity<CoordinatorAccessControlResponse>(response,HttpStatus.OK);
		} catch(Exception ex){
			LOGGER.error("Exception while creating secondary request by {} for event {} {}",accessLog.getUsername(),event.getAutoGeneratedEventId(),ex);
			ErrorResponse errorResponse = new ErrorResponse(ErrorConstants.STATUS_FAILED,DashboardConstants.PROCESSING_FAILED);
			updatePMPAPIAccessLog(accessLog, ErrorConstants.STATUS_FAILED, StackTraceUtils.convertStackTracetoString(ex), StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<ErrorResponse>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}



	/**
	 * This method is used to approve the requests raised 
	 * against a particular event.
	 * @param token ,Token to be validated against MySRCM endpoint.
	 * @param pgrmCoordinators Details of the secondary coordinators
	 * who wants to raise a request to access other events
	 * @param httpRequest to get the requested url details.
	 * @return CoordinatorAccessControlResponse depending on the 
	 * success or failure response.
	 */
	@RequestMapping(value = "/approve", method = RequestMethod.POST,
			consumes = MediaType.APPLICATION_JSON_VALUE,
			produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity<?> approveSecondaryCoordinatorRequest(@RequestHeader(value = "Authorization") String authToken,@RequestBody ProgramCoordinators pgrmCoordinators
			,@Context HttpServletRequest httpRequest) {

		//save request details in PMP
		PMPAPIAccessLog accessLog = createPMPAPIAccessLog(null,httpRequest,StackTraceUtils.convertPojoToJson(pgrmCoordinators));

		//validate token details
		PMPResponse pmpResponse = authTokenVldtr.validateAuthToken(authToken, accessLog);
		if(pmpResponse instanceof ErrorResponse){
			return new ResponseEntity<PMPResponse>(pmpResponse, HttpStatus.OK);
		}

		User user = userProfileService.loadUserByEmail(accessLog.getUsername());

		if (null == user) {

			LOGGER.info(DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			ErrorResponse eResponse = new ErrorResponse(ErrorConstants.STATUS_FAILED,DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			accessLog.setErrorMessage(DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			updatePMPAPIAccessLog(accessLog,ErrorConstants.STATUS_FAILED,DashboardConstants.USER_UNAVAILABLE_IN_PMP, StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<ErrorResponse>(eResponse, HttpStatus.BAD_REQUEST);
		}

		List<String> approverList = new ArrayList<String>();
		if(null != user.getAbyasiId()){
			approverList = userProfileService.getEmailsWithAbhyasiId(user.getAbyasiId());
		}
		if(approverList.size() == 0){
			approverList.add(accessLog.getUsername());
		}

		try{
			CoordinatorAccessControlResponse response = coordntrAccssCntrlValidator.validateCoordinatorRequest(approverList,user.getRole(),pgrmCoordinators);
			if(response instanceof CoordinatorAccessControlErrorResponse){
				updatePMPAPIAccessLog(accessLog,ErrorConstants.STATUS_FAILED,((CoordinatorAccessControlErrorResponse) response).getError_description(), StackTraceUtils.convertPojoToJson(response));
				return new ResponseEntity<CoordinatorAccessControlResponse>(response,HttpStatus.OK);
			}else {
				CoordinatorAccessControlResponse srcvResponse = coordntrAccssCntrlSrcv.approveSecondaryCoordinatorRequest(accessLog.getUsername(),pgrmCoordinators,accessLog);
				return new ResponseEntity<CoordinatorAccessControlResponse>(srcvResponse,HttpStatus.OK);
			}
		} catch(Exception e){
			LOGGER.error("Exception while approving request by {} for event {} {}",accessLog.getUsername(),pgrmCoordinators.getEventId(),e);
			ErrorResponse eResponse = new ErrorResponse(ErrorConstants.STATUS_FAILED,DashboardConstants.PROCESSING_FAILED);
			updatePMPAPIAccessLog(accessLog, ErrorConstants.STATUS_FAILED, StackTraceUtils.convertStackTracetoString(e), StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<ErrorResponse>(eResponse, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}


	/**
	 * This method is used to get the list of pending
	 * request and approved request for a particular event.
	 * @param token,Token to be validated against MySRCM endpoint.
	 * @param event , eventId is used to get the list for an event.
	 * @param httpRequest httpRequest to get the requested url details.
	 * @return List<SecondaryCoordinatorRequest> or empty list depending
	 * if any request are available or not.
	 */
	@RequestMapping(value = "/getsecondarycoordinatorrequests", 
			method = RequestMethod.POST, 
			consumes = MediaType.APPLICATION_JSON_VALUE , 
			produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity<?> getRequestedCoordinatorList(@RequestHeader(value = "Authorization") String authToken,@Context HttpServletRequest httpRequest){

		//save request details in PMP
		PMPAPIAccessLog accessLog = createPMPAPIAccessLog(null,httpRequest,authToken);

		//validate token details
		PMPResponse pmpResponse = authTokenVldtr.validateAuthToken(authToken, accessLog);
		if(pmpResponse instanceof ErrorResponse){
			return new ResponseEntity<PMPResponse>(pmpResponse, HttpStatus.OK);
		}

		User user = userProfileService.loadUserByEmail(accessLog.getUsername());
		if (null == user) {
			LOGGER.info(DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			ErrorResponse eResponse = new ErrorResponse(ErrorConstants.STATUS_FAILED,DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			accessLog.setErrorMessage(DashboardConstants.USER_UNAVAILABLE_IN_PMP);
			updatePMPAPIAccessLog(accessLog,ErrorConstants.STATUS_FAILED,DashboardConstants.USER_UNAVAILABLE_IN_PMP, StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<ErrorResponse>(eResponse, HttpStatus.BAD_REQUEST);
		}

		List<String> emailList = new ArrayList<String>();
		if(null != user.getAbyasiId()){
			emailList = userProfileService.getEmailsWithAbhyasiId(user.getAbyasiId());
		}
		if(emailList.size() == 0){
			emailList.add(accessLog.getUsername());
		}

		try{
			LinkedHashMap<Integer,String> programIds; /*= new HashMap<Integer, String>();*/
			//programIds = coordntrAccssCntrlValidator.getProgramAndagEventIds(emailList,user.getRole());
			programIds = coordntrAccssCntrlValidator.getProgramAndagEventIds(emailList, user.getRole(), authToken, accessLog);

			if(programIds.isEmpty()){
				CoordinatorAccessControlErrorResponse eResponse = 
						new CoordinatorAccessControlErrorResponse(ErrorConstants.STATUS_FAILED, CoordinatorAccessControlConstants.REQUESTERLIST_EMPTY);
				updatePMPAPIAccessLog(accessLog, ErrorConstants.STATUS_FAILED, "Event Requests are not available for logged in user "+emailList, StackTraceUtils.convertPojoToJson(eResponse));
				return new ResponseEntity<CoordinatorAccessControlErrorResponse>(eResponse,HttpStatus.OK);
			}else{
				return coordntrAccssCntrlSrcv.getListOfSecondaryCoordinatorRequests(programIds,accessLog);
			}

		} catch(Exception ex){
			LOGGER.error("Exception while fetching request for {} {}",accessLog.getUsername(),ex);
			ErrorResponse eResponse = new ErrorResponse(ErrorConstants.STATUS_FAILED,DashboardConstants.PROCESSING_FAILED);
			updatePMPAPIAccessLog(accessLog, ErrorConstants.STATUS_FAILED, StackTraceUtils.convertStackTracetoString(ex), StackTraceUtils.convertPojoToJson(eResponse));
			return new ResponseEntity<ErrorResponse>(eResponse, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}


	private PMPAPIAccessLog createPMPAPIAccessLog(String username,HttpServletRequest httpRequest,String requestBody){

		PMPAPIAccessLog accessLog = new PMPAPIAccessLog(username, httpRequest.getRemoteAddr(), 
				httpRequest.getRequestURI(),DateUtils.getCurrentTimeInMilliSec(), null, 
				ErrorConstants.STATUS_FAILED, null,requestBody);
		apiAccessLogService.createPmpAPIAccessLog(accessLog);
		return accessLog;
	}


	private void updatePMPAPIAccessLog(PMPAPIAccessLog pmpApiAccessLog, String status, String errorMessage, String responseBody){

		pmpApiAccessLog.setStatus(status);
		pmpApiAccessLog.setErrorMessage(errorMessage);
		pmpApiAccessLog.setTotalResponseTime(DateUtils.getCurrentTimeInMilliSec());
		pmpApiAccessLog.setResponseBody(responseBody);
		apiAccessLogService.updatePmpAPIAccessLog(pmpApiAccessLog);
	}
}
